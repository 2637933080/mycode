import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import cv2
from PIL import Image, ImageTk
import numpy as np
import os

class FaceDetectorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("人脸识别工具")
        self.root.geometry("800x600")
        
        # 初始化人脸分类器
        self.face_cascade = cv2.CascadeClassifier(
            cv2.data.haarcascades + 'haarcascade_frontalface_default.xml'
        )
        
        # 创建变量
        self.image_path = None
        self.original_image = None
        self.processed_image = None
        self.display_image_obj = None  # 用于存储当前显示的图像对象
        
        self.create_widgets()
    
    def create_widgets(self):
        # 创建顶部控制面板
        control_frame = ttk.Frame(self.root)
        control_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=10)
        
        # 选择图片按钮
        self.select_btn = ttk.Button(control_frame, text="选择图片", command=self.select_image)
        self.select_btn.pack(side=tk.LEFT, padx=5)
        
        # 检测人脸按钮
        self.detect_btn = ttk.Button(control_frame, text="检测人脸", command=self.detect_faces, state=tk.DISABLED)
        self.detect_btn.pack(side=tk.LEFT, padx=5)
        
        # 保存结果按钮
        self.save_btn = ttk.Button(control_frame, text="保存结果", command=self.save_image, state=tk.DISABLED)
        self.save_btn.pack(side=tk.LEFT, padx=5)
        
        # 参数设置
        param_frame = ttk.LabelFrame(control_frame, text="参数设置")
        param_frame.pack(side=tk.LEFT, padx=20)
        
        # Scale Factor
        ttk.Label(param_frame, text="Scale Factor:").grid(row=0, column=0, sticky=tk.W)
        self.scale_var = tk.DoubleVar(value=1.2)
        self.scale_spin = ttk.Spinbox(param_frame, from_=1.1, to=2.0, increment=0.1, textvariable=self.scale_var, width=5)
        self.scale_spin.grid(row=0, column=1, padx=5)
        
        # Min Neighbors
        ttk.Label(param_frame, text="Min Neighbors:").grid(row=1, column=0, sticky=tk.W)
        self.neighbors_var = tk.IntVar(value=5)
        self.neighbors_spin = ttk.Spinbox(param_frame, from_=1, to=10, increment=1, textvariable=self.neighbors_var, width=5)
        self.neighbors_spin.grid(row=1, column=1, padx=5)
        
        # 图像显示区域
        self.canvas_frame = ttk.Frame(self.root)
        self.canvas_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        
        # 创建滚动条
        self.scroll_y = ttk.Scrollbar(self.canvas_frame, orient=tk.VERTICAL)
        self.scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.scroll_x = ttk.Scrollbar(self.canvas_frame, orient=tk.HORIZONTAL)
        self.scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # 创建画布用于显示图像
        self.canvas = tk.Canvas(self.canvas_frame, 
                               yscrollcommand=self.scroll_y.set,
                               xscrollcommand=self.scroll_x.set)
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
        self.scroll_y.config(command=self.canvas.yview)
        self.scroll_x.config(command=self.canvas.xview)
        
        # 状态栏
        self.status_var = tk.StringVar(value="就绪")
        self.status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        # 绑定窗口大小改变事件
        self.root.bind('<Configure>', self.on_window_configure)
        self.last_width = 0
        self.last_height = 0
    
    def select_image(self):
        file_path = filedialog.askopenfilename(
            title="选择图片",
            filetypes=[
                ("Image Files", "*.jpg *.jpeg *.png *.bmp *.tiff"),
                ("All Files", "*.*")
            ]
        )
        
        if file_path:
            self.image_path = file_path
            self.load_image()
            self.detect_btn.config(state=tk.NORMAL)
            self.status_var.set(f"已加载图片: {os.path.basename(file_path)}")
    
    def load_image(self):
        # 使用 OpenCV 读取图像
        self.original_image = cv2.imread(self.image_path)
        if self.original_image is None:
            messagebox.showerror("错误", "无法加载图片")
            return
        
        # 显示图像
        self.display_image(self.original_image)
    
    def resize_image_to_fit_canvas(self, image):
        """调整图像大小以适应画布"""
        canvas_width = self.canvas.winfo_width()
        canvas_height = self.canvas.winfo_height()
        
        # 避免除零错误和负数
        if canvas_width <= 1 or canvas_height <= 1:
            canvas_width = 800
            canvas_height = 500
            
        # 获取原始图像尺寸
        height, width = image.shape[:2]
        
        # 计算缩放比例
        scale_width = canvas_width / width
        scale_height = canvas_height / height
        scale = min(scale_width, scale_height)
        
        # 如果图像比画布小，则不放大
        if scale >= 1:
            return image
        
        # 调整图像大小
        new_width = int(width * scale)
        new_height = int(height * scale)
        resized_image = cv2.resize(image, (new_width, new_height), interpolation=cv2.INTER_AREA)
        
        return resized_image
    
    def display_image(self, image):
        # 先调整图像大小以适应画布
        resized_image = self.resize_image_to_fit_canvas(image)
        
        # 转换颜色格式 BGR to RGB
        rgb_image = cv2.cvtColor(resized_image, cv2.COLOR_BGR2RGB)
        
        # 转换为 PIL Image
        pil_image = Image.fromarray(rgb_image)
        
        # 转换为 Tkinter PhotoImage
        self.display_image_obj = ImageTk.PhotoImage(pil_image)
        
        # 在画布上显示图像
        self.canvas.delete("all")
        self.canvas.create_image(0, 0, anchor=tk.NW, image=self.display_image_obj)
        
        # 更新滚动区域
        self.canvas.config(scrollregion=self.canvas.bbox(tk.ALL))
    
    def on_window_configure(self, event=None):
        """窗口大小改变时的处理函数"""
        # 避免重复调用
        if event.widget != self.root:
            return
            
        if self.root.winfo_width() != self.last_width or self.root.winfo_height() != self.last_height:
            self.last_width = self.root.winfo_width()
            self.last_height = self.root.winfo_height()
            
            # 如果有图像则重新调整大小
            if self.processed_image is not None:
                self.display_image(self.processed_image)
            elif self.original_image is not None:
                self.display_image(self.original_image)
    
    def detect_faces(self):
        if self.original_image is None:
            return
        
        # 获取参数
        scale_factor = self.scale_var.get()
        min_neighbors = self.neighbors_var.get()
        
        # 转换为灰度图
        gray = cv2.cvtColor(self.original_image, cv2.COLOR_BGR2GRAY)
        
        # 检测人脸
        faces = self.face_cascade.detectMultiScale(
            gray, 
            scaleFactor=scale_factor, 
            minNeighbors=min_neighbors
        )
        
        # 绘制矩形框
        self.processed_image = self.original_image.copy()
        for (x, y, w, h) in faces:
            cv2.rectangle(self.processed_image, (x, y), (x+w, y+h), (255, 255, 0), 2)
        
        # 显示处理后的图像
        self.display_image(self.processed_image)
        
        # 启用保存按钮
        self.save_btn.config(state=tk.NORMAL)
        
        # 更新状态栏
        self.status_var.set(f"检测到 {len(faces)} 张人脸")
    
    def save_image(self):
        if self.processed_image is None:
            return
        
        file_path = filedialog.asksaveasfilename(
            title="保存图片",
            defaultextension=".jpg",
            filetypes=[
                ("JPEG files", "*.jpg"),
                ("PNG files", "*.png"),
                ("BMP files", "*.bmp"),
                ("All files", "*.*")
            ]
        )
        
        if file_path:
            success = cv2.imwrite(file_path, self.processed_image)
            if success:
                self.status_var.set(f"图片已保存到: {file_path}")
                messagebox.showinfo("成功", "图片保存成功!")
            else:
                messagebox.showerror("错误", "保存图片失败")

def main():
    root = tk.Tk()
    app = FaceDetectorApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()